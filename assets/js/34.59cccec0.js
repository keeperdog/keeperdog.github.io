(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{363:function(i,l,v){"use strict";v.r(l);var t=v(18),_=Object(t.a)({},(function(){var i=this,l=i._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[l("h1",{attrs:{id:"性能优化"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[i._v("#")]),i._v(" 性能优化")]),i._v(" "),l("h2",{attrs:{id:"加载篇"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#加载篇"}},[i._v("#")]),i._v(" 加载篇")]),i._v(" "),l("p",[l("strong",[i._v("首屏加载优化")])]),i._v(" "),l("ul",[l("li",[i._v("loading 提示\n"),l("ul",[l("li",[i._v("webpack 插件叫 html-webpack-plugin ,在其中配置 html 就可以在文件中插入 loading")])])]),i._v(" "),l("li",[i._v("开启 HTTP2\n"),l("ul",[l("li",[i._v("浏览器并发一次性请求 6 次的限制，配置 nginx 也要支持 http2 模块")])])]),i._v(" "),l("li",[i._v("开启浏览器缓存\n"),l("ul",[l("li",[i._v("Expires & Cache-Control")]),i._v(" "),l("li",[i._v("Etag 和 If-None-Match")]),i._v(" "),l("li",[i._v("If-Modified-Since 和 Last-Modified")]),i._v(" "),l("li",[i._v("SplitChunksPlugin 插件取代了 CommonsChunkPlugin 插件来进行公共模块抽取，我们可以对 SplitChunksPlugin 进行配置进行 拆包 操作")])])])]),i._v(" "),l("p",[l("strong",[l("em",[i._v("坑 1")])]),i._v("：webpack4.x 会给每个 chunk 搭上 id,这个 id 是自增的,比如 chunk 0 中的 id 为 0,一旦我们引入新的依赖,chunk 的自增会被打乱这个问题我们需要额外引入一个插件")]),i._v(" "),l("p",[i._v("HashedModuleIdsPlugin,他用非自增的方式进行 chunk id 的命名,可以解决这个问题,虽然 webpack 号称 0 配置了,但是这个常用功能没有内置。webpack5.x 已经实现")]),i._v(" "),l("ul",[l("li",[l("p",[i._v("Tree Shaking")]),i._v(" "),l("ul",[l("li",[i._v("依赖 es6 的 module 模块的静态特性，通过程序流分析找出你代码中无用的代码并剔除")])])]),i._v(" "),l("li",[l("p",[i._v("动态加载 ES6 代码")]),i._v(" "),l("ul",[l("li",[l("code",[i._v('<script type="module">')]),i._v("这个标签来判断浏览器是否支持 es6")])])]),i._v(" "),l("li",[l("p",[i._v("路由级别拆解代码")]),i._v(" "),l("ul",[l("li",[i._v("Code Splitting 技术进行代码分割，plugin-syntax-dynamic-import 这个动态 import 的插件,然后就可以就函数体内使用 import 了.")]),i._v(" "),l("li",[i._v("对于 react,其内置的 React.lazy() 就可以动态加载路由和组件\n"),l("strong",[i._v("组件懒加载")])])])]),i._v(" "),l("li",[l("p",[i._v("组件懒加载")]),i._v(" "),l("ul",[l("li",[i._v("Code Splitting 不仅可以进行路由分割,甚至可以进行组件级别的代码分割")]),i._v(" "),l("li",[i._v("Lazy + Suspense 的方法进行组件懒加载，原理"),l("strong",[i._v("componentDidCatch")])])])]),i._v(" "),l("li",[l("p",[i._v("组件预加载")]),i._v(" "),l("ul",[l("li",[i._v("是在用户的鼠标还处于 hover 或初始化结束后，总之找到一个合适的契机，的时候就开始触发图表资源的加载,通常情况下当用户点击结束之后")])])]),i._v(" "),l("li",[l("p",[i._v("keep-alive")]),i._v(" "),l("ul",[l("li",[i._v("在页面已经跳转后依然不销毁组件,保存组件对应的实例在内存中,当此页面再次需要渲染的时候就可以利用已经缓存的组件实例了。")]),i._v(" "),l("li",[i._v("react-keep-alive 在一定程度上解决这个问题,它的原理是利用 React 的 Portals API 将缓存组件挂载到根节点以外的 dom 上,在需要恢复的时候再将缓存组件挂在到相应节点上")])])])])])}),[],!1,null,null,null);l.default=_.exports}}]);